name: iOS Automation Testing

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  ios-automation-tests:
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: |
        # Install dependencies with legacy peer deps to handle compatibility issues
        npm install --legacy-peer-deps
      
    - name: Setup iOS Simulator
      run: |
        # List available simulators for debugging
        echo "Available simulators:"
        xcrun simctl list devices available
        
        # Find any iPhone simulator available in CI  
        SIMULATOR_ID=$(xcrun simctl list devices available | grep "iPhone" | head -1 | grep -oE '[0-9A-F-]{36}')
        
        if [ -z "$SIMULATOR_ID" ]; then
          echo "No iPhone simulator found, trying iPad..."
          SIMULATOR_ID=$(xcrun simctl list devices available | grep -E "iPad" | head -1 | grep -oE '[0-9A-F-]{36}')
        fi
        
        if [ -z "$SIMULATOR_ID" ]; then
          echo "ERROR: No iOS simulator found"
          xcrun simctl list devices available
          exit 1
        fi
        
        echo "Using simulator ID: $SIMULATOR_ID"
        xcrun simctl boot "$SIMULATOR_ID" || true
        echo "SIMULATOR_ID=$SIMULATOR_ID" >> $GITHUB_ENV
        
        # Wait for simulator to boot
        echo "Waiting for simulator to boot..."
        xcrun simctl bootstatus "$SIMULATOR_ID" -b
        
    - name: Setup Xcode and CocoaPods
      run: |
        sudo xcode-select -s /Applications/Xcode.app/Contents/Developer
        gem install cocoapods
        echo "‚úÖ Xcode and CocoaPods setup complete"
        
    - name: Generate Native iOS Project
      run: |
        # Prebuild to create native iOS project
        export CI=true
        export EXPO_NO_TELEMETRY=1
        # Skip expo install --fix as it may cause dependency conflicts
        echo "Running expo prebuild for iOS..."
        npx expo prebuild --platform ios --clean || {
          echo "ERROR: expo prebuild failed"
          echo "Node modules status:"
          ls -la node_modules/ | head -5
          echo "Package.json dependencies:"
          cat package.json | grep -A 10 '"dependencies"'
          exit 1
        }
        
        # Verify ios directory was created
        if [ ! -d "ios" ]; then
          echo "ERROR: ios directory not created by prebuild"
          exit 1
        fi
        
        # Check what was generated
        echo "iOS project structure created:"
        ls -la ios/
        echo ""
        echo "Workspace files found:"
        find ios/ -name "*.xcworkspace" -type d || echo "No .xcworkspace files found"
        
        echo "‚úÖ Native iOS project generated successfully"
        
    - name: Build iOS app for testing
      run: |
        cd ios
        
        # Verify workspace exists
        if [ ! -d "Traval.xcworkspace" ]; then
          echo "ERROR: Traval.xcworkspace not found"
          echo "Available files in ios directory:"
          ls -la
          echo ""
          echo "Looking for .xcworkspace files:"
          find . -name "*.xcworkspace" -type d
          exit 1
        fi
        
        # Install pods first
        pod install || {
          echo "ERROR: pod install failed"
          exit 1
        }
        
        # Build for iOS Simulator using xcodebuild (avoids device detection)
        # Use absolute derivedDataPath to ensure consistent build location
        BUILD_DIR="$(pwd)/build"
        
        xcodebuild -workspace Traval.xcworkspace \
          -scheme Traval \
          -configuration Debug \
          -sdk iphonesimulator \
          -destination "platform=iOS Simulator,id=$SIMULATOR_ID" \
          -derivedDataPath "$BUILD_DIR" \
          build || {
          echo "ERROR: Xcode build failed"
          echo "Available schemes:"
          xcodebuild -workspace Traval.xcworkspace -list
          exit 1
        }
        
        # Research-based solution: Use standard Xcode build products path structure
        # Debug-iphonesimulator apps are located at: Build/Products/Debug-iphonesimulator/
        EXPECTED_APP_PATH="$BUILD_DIR/Build/Products/Debug-iphonesimulator/Traval.app"
        
        # Verify the expected path exists first
        if [ -d "$EXPECTED_APP_PATH" ]; then
          APP_PATH="$EXPECTED_APP_PATH"
          echo "‚úÖ Found app at expected location: $APP_PATH"
        else
          echo "‚ö†Ô∏è  App not found at expected location: $EXPECTED_APP_PATH"
          echo "üîç Searching entire build directory..."
          
          # Fallback: search the entire build directory
          APP_PATH=$(find "$BUILD_DIR" -name "Traval.app" -type d | head -1)
          
          if [ -z "$APP_PATH" ]; then
            echo "‚ùå ERROR: No Traval.app bundle found after build"
            echo "Build directory structure:"
            echo "==========================="
            find "$BUILD_DIR" -type d -name "*.app" 2>/dev/null || echo "No .app directories found"
            echo ""
            echo "Complete build directory contents:"
            find "$BUILD_DIR" -name "*" | head -20
            echo ""
            echo "Checking for common iOS build patterns..."
            find "$BUILD_DIR" -name "*Debug*" -type d | head -10
            find "$BUILD_DIR" -name "*iphonesimulator*" -type d | head -10
            exit 1
          else
            echo "‚úÖ Found app via search: $APP_PATH"
          fi
        fi
        
        # Verify app bundle is valid
        if [ ! -d "$APP_PATH" ]; then
          echo "‚ùå ERROR: APP_PATH is not a directory: $APP_PATH"
          exit 1
        fi
        
        # Convert to absolute path for consistency
        APP_PATH=$(cd "$(dirname "$APP_PATH")" && pwd)/$(basename "$APP_PATH")
        echo "üì± Final app path (absolute): $APP_PATH"
        echo "APP_PATH=$APP_PATH" >> $GITHUB_ENV
        
        # Install the app on simulator with enhanced error handling
        echo "üì≤ Installing app on simulator..."
        echo "Simulator ID: $SIMULATOR_ID"
        echo "App Path: $APP_PATH"
        
        # Verify simulator is booted before installation
        SIMULATOR_STATE=$(xcrun simctl list devices | grep "$SIMULATOR_ID" | awk '{print $NF}' | tr -d '()')
        echo "Simulator state: $SIMULATOR_STATE"
        
        if [ "$SIMULATOR_STATE" != "Booted" ]; then
          echo "‚ö†Ô∏è  Simulator not booted, attempting to boot..."
          xcrun simctl boot "$SIMULATOR_ID" || true
          sleep 10
        fi
        
        xcrun simctl install "$SIMULATOR_ID" "$APP_PATH" || {
          echo "‚ùå ERROR: Failed to install app on simulator"
          echo "Debug information:"
          echo "=================="
          echo "Simulator status:"
          xcrun simctl list devices | grep "$SIMULATOR_ID"
          echo ""
          echo "App path verification:"
          ls -la "$APP_PATH"
          echo ""
          echo "App bundle info:"
          file "$APP_PATH" || echo "Could not determine file type"
          exit 1
        }
        echo "‚úÖ iOS app built and installed successfully"
        
    - name: Install Automation Dependencies
      run: |
        cd automation
        npm install --legacy-peer-deps
        echo "‚úÖ Automation dependencies installed"
        
    - name: Verify app installation
      run: |
        # Verify the app is installed
        xcrun simctl listapps "$SIMULATOR_ID" | grep "com.voyager.rn" || {
          echo "ERROR: App com.voyager.rn not found on simulator"
          echo "Installed apps:"
          xcrun simctl listapps "$SIMULATOR_ID"
          exit 1
        }
        echo "‚úÖ App com.voyager.rn is installed and ready for testing"
        
    - name: Start Appium Server
      run: |
        # Create automation log directory
        mkdir -p automation/simulator.log
        # Use the project's automation devDependencies to run Appium via npx
        # This avoids global install/version mismatches and ESM/CommonJS issues
        echo "üì¶ Installing automation devDependencies (including Appium)..."
        cd automation
        if [ -f package-lock.json ]; then
          npm ci --legacy-peer-deps || { echo "‚ùå npm ci failed"; exit 1; }
        else
          npm install --legacy-peer-deps || { echo "‚ùå npm install failed"; exit 1; }
        fi

        # Verify local appium is available
        echo "üîç Verifying local Appium installation via npx"
        APPIUM_VERSION=$(npx --no-install appium --version 2>/dev/null || npx appium --version 2>/dev/null || true)
        echo "Appium version reported: $APPIUM_VERSION"

        # Clean up any existing drivers and install xcuitest via npx (works for Appium 2 and 3)
        echo "üßπ Ensuring drivers are installed via npx appium"
        npx appium driver list --installed 2>/dev/null || true
        npx appium driver uninstall xcuitest 2>/dev/null || true
        npx appium driver uninstall uiautomator2 2>/dev/null || true

        echo "üîß Installing xcuitest driver via npx appium"
        npx appium driver install xcuitest || { echo "‚ùå Failed to install xcuitest driver via npx"; tail -50 automation/simulator.log/appium.log 2>/dev/null || true; exit 1; }

        echo "‚úÖ Installed drivers (if applicable):"
        npx appium driver list --installed || true

        # Start Appium server in background using npx to ensure correct dependency tree
        echo "üöÄ Starting Appium server via npx appium..."
        nohup npx appium --log-level warn --port 4723 &> ../automation/simulator.log/appium.log &
        APPIUM_PID=$!
        echo "APPIUM_PID=$APPIUM_PID" >> $GITHUB_ENV
        echo "Appium PID: $APPIUM_PID"

        # Wait for Appium to start
        echo "‚è≥ Waiting for Appium to start..."
        sleep 15

        # Verify Appium is running
        echo "üîç Checking Appium server status..."
        if ! curl -f http://localhost:4723/status; then
          echo "‚ùå ERROR: Appium server not responding"
          echo "üìã Debug information:"
          echo "Checking Appium process..."
          ps aux | grep appium || echo "No Appium process found"
          echo "Checking if port 4723 is in use:"
          lsof -i :4723 || echo "Port 4723 not in use"
          echo "Last 50 lines of Appium log:" 
          tail -50 ../automation/simulator.log/appium.log 2>/dev/null || echo "No log file found"
          exit 1
        fi
        echo "‚úÖ Appium server is running and responding"
        
    - name: Run iOS Automation Tests
      env:
        SIMULATOR_ID: ${{ env.SIMULATOR_ID }}
        APP_PATH: ${{ env.APP_PATH }}
      run: |
        cd automation
        
        # Validate environment variables before testing
        echo "üß™ Pre-test validation:"
        echo "Simulator ID: $SIMULATOR_ID"
        echo "App Path: $APP_PATH"
        
        # Verify app path exists and is accessible
        if [ ! -d "$APP_PATH" ]; then
          echo "‚ùå ERROR: App path does not exist or is not accessible: $APP_PATH"
          echo "Current working directory: $(pwd)"
          echo "Parent directory listing:"
          ls -la ../ios/build/ || echo "Build directory not found"
          exit 1
        fi
        
        # Verify app bundle structure
        echo "üì± App bundle validation:"
        echo "App bundle exists: ‚úÖ"
        echo "App bundle contents:"
        ls -la "$APP_PATH/" | head -5
        
        # Check app info
        if [ -f "$APP_PATH/Info.plist" ]; then
          echo "Bundle identifier: $(plutil -extract CFBundleIdentifier raw "$APP_PATH/Info.plist" 2>/dev/null || echo 'Could not read')"
        fi
        
        echo "üöÄ Starting iOS automation tests..."
        export PLATFORM=ios
        export CI=true
        npx wdio run wdio.mobile.conf.ts --spec tests/mobile/travel-preferences.test.ts
        
    - name: Capture test artifacts on failure
      if: failure()
      run: |
        echo "üì∏ Capturing debug information..."
        
        # Ensure directories exist
        mkdir -p automation/logs
        mkdir -p automation/screenshots
        mkdir -p automation/simulator.log
        
        # Capture simulator screenshot
        if [ ! -z "$SIMULATOR_ID" ]; then
          echo "Taking simulator screenshot..."
          xcrun simctl io "$SIMULATOR_ID" screenshot "automation/screenshots/simulator-screenshot.png" 2>/dev/null || echo "Failed to capture screenshot"
        fi
        
        # Capture simulator logs
        if [ ! -z "$SIMULATOR_ID" ]; then
          echo "Collecting simulator logs..."
          xcrun simctl spawn "$SIMULATOR_ID" log collect --output "automation/simulator.log/system.log" 2>/dev/null || echo "Failed to collect logs"
        fi
        
        # List running apps for debugging
        if [ ! -z "$SIMULATOR_ID" ]; then
          echo "Listing installed apps..."
          xcrun simctl listapps "$SIMULATOR_ID" > "automation/logs/installed-apps.txt" 2>/dev/null || echo "Failed to list apps"
        fi
        
        # Copy Appium logs if they exist
        if [ -f "automation/simulator.log/appium.log" ]; then
          echo "Appium log found, size: $(wc -l < automation/simulator.log/appium.log) lines"
          tail -200 automation/simulator.log/appium.log > automation/logs/appium-tail.log || true
        else
          echo "‚ö†Ô∏è No Appium log file found at automation/simulator.log/appium.log"
        fi
        
        echo "‚úÖ Artifact capture complete"
        
    - name: Dump Appium logs on failure
      if: failure()
      run: |
        echo "üìã Displaying last 200 lines of Appium log for quick debugging:"
        echo "================================================================"
        if [ -f "automation/simulator.log/appium.log" ]; then
          tail -200 automation/simulator.log/appium.log
        else
          echo "‚ö†Ô∏è Appium log file not found"
          echo "Searching for any Appium-related logs..."
          find automation -name "*appium*" -type f 2>/dev/null || echo "No Appium logs found"
        fi
        
    - name: Upload Test Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ios-test-results-${{ github.run_number }}
        path: |
          automation/logs/
          automation/screenshots/
          automation/*.log
          automation/*.png
          automation/*.txt
          
    - name: Cleanup
      if: always()
      run: |
        echo "Cleaning up..."
        
        # Kill Appium server
        if [ ! -z "$APPIUM_PID" ]; then
          echo "Killing Appium server (PID: $APPIUM_PID)"
          kill $APPIUM_PID || true
        fi
        
        # Kill any remaining appium processes
        echo "Cleaning up any remaining Appium processes..."
        pkill -f appium || true
        pkill -f "node.*appium" || true
        
        # Shutdown simulator
        if [ ! -z "$SIMULATOR_ID" ]; then
          echo "Shutting down simulator: $SIMULATOR_ID"
          xcrun simctl shutdown "$SIMULATOR_ID" || true
        fi
        
        # Clean up build artifacts to save space
        rm -rf ios/build || true
        rm -rf ~/Library/Developer/Xcode/DerivedData/* || true