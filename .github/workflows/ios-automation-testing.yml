name: iOS Automation Testing

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  ios-automation-tests:
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Clean committed iOS directory
      run: |
        echo "üßπ Removing committed ios directory (will be regenerated)..."
        rm -rf ios
        echo "‚úÖ Clean complete - expo prebuild will regenerate fresh iOS project"
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        # Use Node 20 to satisfy newer automation dependencies (cheerio, undici, etc.)
        node-version: '20'
        cache: 'npm'
        
    - name: Install dependencies
      run: |
        # Use legacy peer deps to handle known upstream peer conflicts in CI
        export npm_config_legacy_peer_deps=true
        npm install --legacy-peer-deps
      
    - name: Setup iOS Simulator
      run: |
        # List available simulators for debugging
        echo "Available simulators:"
        xcrun simctl list devices available
        
        # Find any iPhone simulator available in CI  
        SIMULATOR_ID=$(xcrun simctl list devices available | grep "iPhone" | head -1 | grep -oE '[0-9A-F-]{36}')
        
        if [ -z "$SIMULATOR_ID" ]; then
          echo "No iPhone simulator found, trying iPad..."
          SIMULATOR_ID=$(xcrun simctl list devices available | grep -E "iPad" | head -1 | grep -oE '[0-9A-F-]{36}')
        fi
        
        if [ -z "$SIMULATOR_ID" ]; then
          echo "ERROR: No iOS simulator found"
          xcrun simctl list devices available
          exit 1
        fi
        
        echo "Using simulator ID: $SIMULATOR_ID"
        xcrun simctl boot "$SIMULATOR_ID" || true
        echo "SIMULATOR_ID=$SIMULATOR_ID" >> $GITHUB_ENV
        
        # Wait for simulator to boot
        echo "Waiting for simulator to boot..."
        xcrun simctl bootstatus "$SIMULATOR_ID" -b
        
    - name: Setup Xcode and CocoaPods
      run: |
        sudo xcode-select -s /Applications/Xcode.app/Contents/Developer
        gem install cocoapods
        echo "‚úÖ Xcode and CocoaPods setup complete"
        
    - name: Generate Native iOS Project
      run: |
        # Prebuild to create native iOS project
        export CI=true
        export EXPO_NO_TELEMETRY=1
        # Skip expo install --fix as it may cause dependency conflicts
        echo "Running expo prebuild for iOS..."
        npx expo prebuild --platform ios --clean || {
          echo "ERROR: expo prebuild failed"
          echo "Node modules status:"
          ls -la node_modules/ | head -5
          echo "Package.json dependencies:"
          cat package.json | grep -A 10 '"dependencies"'
          exit 1
        }
        
        # Verify ios directory was created
        if [ ! -d "ios" ]; then
          echo "ERROR: ios directory not created by prebuild"
          exit 1
        fi
        
        # Check what was generated
        echo "iOS project structure created:"
        ls -la ios/
        echo ""
        echo "Workspace files found:"
        find ios/ -name "*.xcworkspace" -type d || echo "No .xcworkspace files found"
        
        echo "‚úÖ Native iOS project generated successfully"
        
    - name: Build iOS app for testing
      run: |
        cd ios
        
        # Verify workspace exists (name changed to TravalPass after regeneration)
        if [ ! -d "TravalPass.xcworkspace" ]; then
          echo "ERROR: TravalPass.xcworkspace not found"
          echo "Available files in ios directory:"
          ls -la
          echo ""
          echo "Looking for .xcworkspace files:"
          find . -name "*.xcworkspace" -type d
          exit 1
        fi
        
        # Install pods first
        pod install || {
          echo "ERROR: pod install failed"
          exit 1
        }
        
        # Build for iOS Simulator using xcodebuild (avoids device detection)
        # Use absolute derivedDataPath to ensure consistent build location
        BUILD_DIR="$(pwd)/build"
        
        xcodebuild -workspace TravalPass.xcworkspace \
          -scheme TravalPass \
          -configuration Debug \
          -sdk iphonesimulator \
          -destination "platform=iOS Simulator,id=$SIMULATOR_ID" \
          -derivedDataPath "$BUILD_DIR" \
          build || {
          echo "ERROR: Xcode build failed"
          echo "Available schemes:"
          xcodebuild -workspace TravalPass.xcworkspace -list
          exit 1
        }
        
        # Research-based solution: Use standard Xcode build products path structure
        # Debug-iphonesimulator apps are located at: Build/Products/Debug-iphonesimulator/
        EXPECTED_APP_PATH="$BUILD_DIR/Build/Products/Debug-iphonesimulator/TravalPass.app"
        
        # Verify the expected path exists first
        if [ -d "$EXPECTED_APP_PATH" ]; then
          APP_PATH="$EXPECTED_APP_PATH"
          echo "‚úÖ Found app at expected location: $APP_PATH"
        else
          echo "‚ö†Ô∏è  App not found at expected location: $EXPECTED_APP_PATH"
          echo "üîç Searching entire build directory..."
          
          # Fallback: search the entire build directory
          APP_PATH=$(find "$BUILD_DIR" -name "TravalPass.app" -type d | head -1)
          
          if [ -z "$APP_PATH" ]; then
            echo "‚ùå ERROR: No TravalPass.app bundle found after build"
            echo "Build directory structure:"
            echo "==========================="
            find "$BUILD_DIR" -type d -name "*.app" 2>/dev/null || echo "No .app directories found"
            echo ""
            echo "Complete build directory contents:"
            find "$BUILD_DIR" -name "*" | head -20
            echo ""
            echo "Checking for common iOS build patterns..."
            find "$BUILD_DIR" -name "*Debug*" -type d | head -10
            find "$BUILD_DIR" -name "*iphonesimulator*" -type d | head -10
            exit 1
          else
            echo "‚úÖ Found app via search: $APP_PATH"
          fi
        fi
        
        # Verify app bundle is valid
        if [ ! -d "$APP_PATH" ]; then
          echo "‚ùå ERROR: APP_PATH is not a directory: $APP_PATH"
          exit 1
        fi
        
        # Convert to absolute path for consistency
        APP_PATH=$(cd "$(dirname "$APP_PATH")" && pwd)/$(basename "$APP_PATH")
        echo "üì± Final app path (absolute): $APP_PATH"
        echo "APP_PATH=$APP_PATH" >> $GITHUB_ENV
        
        # Install the app on simulator with enhanced error handling
        echo "üì≤ Installing app on simulator..."
        echo "Simulator ID: $SIMULATOR_ID"
        echo "App Path: $APP_PATH"
        
        # Verify simulator is booted before installation
        SIMULATOR_STATE=$(xcrun simctl list devices | grep "$SIMULATOR_ID" | awk '{print $NF}' | tr -d '()')
        echo "Simulator state: $SIMULATOR_STATE"
        
        if [ "$SIMULATOR_STATE" != "Booted" ]; then
          echo "‚ö†Ô∏è  Simulator not booted, attempting to boot..."
          xcrun simctl boot "$SIMULATOR_ID" || true
          sleep 10
        fi
        
        xcrun simctl install "$SIMULATOR_ID" "$APP_PATH" || {
          echo "‚ùå ERROR: Failed to install app on simulator"
          echo "Debug information:"
          echo "=================="
          echo "Simulator status:"
          xcrun simctl list devices | grep "$SIMULATOR_ID"
          echo ""
          echo "App path verification:"
          ls -la "$APP_PATH"
          echo ""
          echo "App bundle info:"
          file "$APP_PATH" || echo "Could not determine file type"
          exit 1
        }
        echo "‚úÖ iOS app built and installed successfully"
        
        # Launch the app explicitly and wait for it to initialize
        echo "üöÄ Launching app explicitly on simulator..."
        xcrun simctl launch "$SIMULATOR_ID" com.voyager.rn || {
          echo "‚ö†Ô∏è WARNING: App launch command failed, but continuing..."
        }
        
        # Wait longer for React Native bundle to load and app to fully initialize
        # CI environments are slower, so we need more time
        echo "‚è≥ Waiting for React Native bundle to load (45 seconds for CI)..."
        sleep 45
        echo "‚úÖ Initial wait complete"
        
        # Verify app is still running after initial wait
        echo "üîç Verifying app is running..."
        APP_PID=$(xcrun simctl spawn "$SIMULATOR_ID" ps aux | grep -i "TravalPass" | grep -v grep | awk '{print $2}' | head -1)
        if [ -z "$APP_PID" ]; then
          echo "‚ö†Ô∏è WARNING: App process not found after launch, attempting relaunch..."
          xcrun simctl launch "$SIMULATOR_ID" com.voyager.rn || true
          sleep 20
        else
          echo "‚úÖ App is running with PID: $APP_PID"
        fi
        
        # Capture initial app state for debugging
        echo "üì∏ Capturing initial app state..."
        mkdir -p automation/logs/launch-diagnostics
        
        # Take screenshot of initial state
        xcrun simctl io "$SIMULATOR_ID" screenshot "automation/logs/launch-diagnostics/initial-state.png" || true
        
        # Get app process status
        echo "App process status:" > automation/logs/launch-diagnostics/app-status.txt
        xcrun simctl spawn "$SIMULATOR_ID" ps aux | grep -i TravalPass >> automation/logs/launch-diagnostics/app-status.txt || true
        
        # Check for any crash logs immediately after launch
        echo "üîç Checking for early crash logs..."
        CRASH_LOGS=$(find ~/Library/Logs/DiagnosticReports -name "*TravalPass*" -mmin -2 2>/dev/null || true)
        if [ -n "$CRASH_LOGS" ]; then
          echo "‚ö†Ô∏è WARNING: Found recent crash logs:"
          echo "$CRASH_LOGS"
          mkdir -p automation/logs/crash-logs
          cp ~/Library/Logs/DiagnosticReports/*TravalPass* automation/logs/crash-logs/ 2>/dev/null || true
        fi
        
        echo "‚úÖ Launch diagnostics captured"
        
    - name: Install Automation Dependencies
      run: |
        cd automation
        # Prevent chromedriver auto-download (often fails on CI) and allow legacy peer deps
        export npm_config_legacy_peer_deps=true
        export APPIUM_SKIP_CHROMEDRIVER_INSTALL=true
        if [ -f package-lock.json ]; then
          npm ci --legacy-peer-deps || npm install --legacy-peer-deps
        else
          npm install --legacy-peer-deps
        fi
        echo "‚úÖ Automation dependencies installed (chromedriver download skipped)"
        
    - name: Verify app installation
      run: |
        # Verify the app is installed
        xcrun simctl listapps "$SIMULATOR_ID" | grep "com.voyager.rn" || {
          echo "ERROR: App com.voyager.rn not found on simulator"
          echo "Installed apps:"
          xcrun simctl listapps "$SIMULATOR_ID"
          exit 1
        }
        echo "‚úÖ App com.voyager.rn is installed and ready for testing"
        
    - name: Start Appium Server
      run: |
        # Create automation log directory
        mkdir -p automation/simulator.log
        # Use the project's automation devDependencies to run Appium via npx
        # This avoids global install/version mismatches and ESM/CommonJS issues
        echo "üì¶ Installing automation devDependencies (including Appium)..."
        cd automation
        if [ -f package-lock.json ]; then
          npm ci --legacy-peer-deps || { echo "‚ùå npm ci failed"; exit 1; }
        else
          npm install --legacy-peer-deps || { echo "‚ùå npm install failed"; exit 1; }
        fi

        # Verify local appium is available and ensure Appium 3.x is installed when required
        echo "üîç Verifying local Appium installation via npx"
        APPIUM_VERSION=$(npx --no-install appium --version 2>/dev/null || npx appium --version 2>/dev/null || true)
        echo "Appium version reported: $APPIUM_VERSION"

        # If Appium is not present or is < 3, install Appium 3.x RC locally in automation
        MAJOR_VERSION=$(echo "$APPIUM_VERSION" | cut -d. -f1 2>/dev/null || echo "0")
        if [ -z "$APPIUM_VERSION" ] || [ "$MAJOR_VERSION" -lt 3 ]; then
          echo "üîß Installing Appium 3.x (appium@3.0.0-rc.2) locally in automation..."
          npm install appium@3.0.0-rc.2 --no-save --legacy-peer-deps || {
            echo "‚ùå Failed to install appium@3.0.0-rc.2 locally"; tail -50 automation/simulator.log/appium.log 2>/dev/null || true; exit 1;
          }
          APPIUM_VERSION=$(npx appium --version 2>/dev/null || true)
          echo "New Appium version reported: $APPIUM_VERSION"
        fi

        # Recompute major version and validate compatibility
        MAJOR_VERSION=$(echo "$APPIUM_VERSION" | cut -d. -f1 2>/dev/null || echo "0")
        if [ "$MAJOR_VERSION" -lt 3 ]; then
          echo "‚ùå Appium major version is < 3; xcuitest driver requires Appium 3.x"
          echo "Appium version: $APPIUM_VERSION"
          exit 1
        fi

        # Clean up any existing drivers and install xcuitest via npx appium
        echo "üßπ Ensuring drivers are installed via npx appium"
        npx appium driver list --installed 2>/dev/null || true
        npx appium driver uninstall xcuitest 2>/dev/null || true
        npx appium driver uninstall uiautomator2 2>/dev/null || true

        echo "üîß Installing xcuitest driver via npx appium"
        npx appium driver install xcuitest || { echo "‚ùå Failed to install xcuitest driver via npx"; tail -50 automation/simulator.log/appium.log 2>/dev/null || true; exit 1; }

        echo "‚úÖ Installed drivers (if applicable):"
        npx appium driver list --installed || true

        # Start Appium server in background using npx to ensure correct dependency tree
        echo "üöÄ Starting Appium server via npx appium..."
        nohup npx appium --log-level warn --port 4723 &> ../automation/simulator.log/appium.log &
        APPIUM_PID=$!
        echo "APPIUM_PID=$APPIUM_PID" >> $GITHUB_ENV
        echo "Appium PID: $APPIUM_PID"

        # Wait for Appium to start
        echo "‚è≥ Waiting for Appium to start..."
        sleep 15

        # Verify Appium is running
        echo "üîç Checking Appium server status..."
        if ! curl -f http://localhost:4723/status; then
          echo "‚ùå ERROR: Appium server not responding"
          echo "üìã Debug information:"
          echo "Checking Appium process..."
          ps aux | grep appium || echo "No Appium process found"
          echo "Checking if port 4723 is in use:"
          lsof -i :4723 || echo "Port 4723 not in use"
          echo "Last 50 lines of Appium log:" 
          tail -50 ../automation/simulator.log/appium.log 2>/dev/null || echo "No log file found"
          exit 1
        fi
        echo "‚úÖ Appium server is running and responding"
        
    - name: Run iOS Automation Tests
      env:
        SIMULATOR_ID: ${{ env.SIMULATOR_ID }}
        APP_PATH: ${{ env.APP_PATH }}
      run: |
        cd automation
        
        # Validate environment variables before testing
        echo "üß™ Pre-test validation:"
        echo "Simulator ID: $SIMULATOR_ID"
        echo "App Path: $APP_PATH"
        
        # Verify app path exists and is accessible
        if [ ! -d "$APP_PATH" ]; then
          echo "‚ùå ERROR: App path does not exist or is not accessible: $APP_PATH"
          echo "Current working directory: $(pwd)"
          echo "Parent directory listing:"
          ls -la ../ios/build/ || echo "Build directory not found"
          exit 1
        fi
        
        # Verify app bundle structure
        echo "üì± App bundle validation:"
        echo "App bundle exists: ‚úÖ"
        echo "App bundle contents:"
        ls -la "$APP_PATH/" | head -5

        # Check app info
        if [ -f "$APP_PATH/Info.plist" ]; then
          echo "Bundle identifier: $(plutil -extract CFBundleIdentifier raw \"$APP_PATH/Info.plist\" 2>/dev/null || echo 'Could not read')"
        fi
        
        # Check app is running before tests start
          echo "üîç Checking if app is running..."
          APP_RUNNING=$(xcrun simctl spawn "$SIMULATOR_ID" ps aux | grep -i TravalPass | grep -v grep || echo "")
        if [ -z "$APP_RUNNING" ]; then
          echo "‚ö†Ô∏è WARNING: App doesn't appear to be running, attempting to launch..."
          xcrun simctl launch "$SIMULATOR_ID" com.voyager.rn || true
          sleep 10
        else
          echo "‚úÖ App is running"
        fi

        echo "üöÄ Starting iOS automation tests..."
        export PLATFORM=ios
        export CI=true
        # Run ALL mobile e2e tests instead of just one test file
        # Tests will run in sequence: login, profile-edit, travel-preferences, create-manual-itinerary
        echo "üìã Running all iOS e2e tests..."
        npx wdio run wdio.mobile.conf.ts || {
          echo "‚ùå Tests failed, capturing post-failure diagnostics..."
          
          # Capture screenshot after test failure
          mkdir -p logs/test-failure
          xcrun simctl io "$SIMULATOR_ID" screenshot "logs/test-failure/failure-state.png" || true
          
          # Capture app process state
          echo "App process after failure:" > logs/test-failure/app-status-after.txt
          xcrun simctl spawn "$SIMULATOR_ID" ps aux | grep -i traval >> logs/test-failure/app-status-after.txt || true
          
          exit 1
        }
        
    - name: Capture test artifacts on failure
      if: failure()
      run: |
        echo "üì∏ Capturing debug information..."
        
        # Ensure directories exist
        mkdir -p automation/logs
        mkdir -p automation/screenshots
        mkdir -p automation/simulator.log
        mkdir -p automation/logs/crash-logs
        
        # Capture simulator screenshot
        if [ ! -z "$SIMULATOR_ID" ]; then
          echo "Taking simulator screenshot..."
          xcrun simctl io "$SIMULATOR_ID" screenshot "automation/screenshots/simulator-screenshot.png" 2>/dev/null || echo "Failed to capture screenshot"
        fi
        
        # Capture simulator logs focused on Traval app
        if [ ! -z "$SIMULATOR_ID" ]; then
          echo "Collecting Traval app logs (last 5 minutes)..."
          xcrun simctl spawn "$SIMULATOR_ID" log show --predicate 'processImagePath contains "Traval"' --last 5m \
            > automation/logs/traval-app.log 2>&1 || echo "‚ö†Ô∏è Could not capture app-specific logs"
          
          echo "Collecting system log..."
          xcrun simctl spawn "$SIMULATOR_ID" log collect --output "automation/simulator.log/system.log" 2>/dev/null || echo "Failed to collect full system log"
        fi
        
        # Check for crash logs
        if [ ! -z "$SIMULATOR_ID" ]; then
          echo "Checking for crash logs..."
          CRASH_LOGS=$(find ~/Library/Logs/DiagnosticReports -name "*Traval*" -mtime -1 2>/dev/null || true)
          if [ -n "$CRASH_LOGS" ]; then
            echo "Found crash logs:"
            echo "$CRASH_LOGS"
            cp ~/Library/Logs/DiagnosticReports/*Traval* automation/logs/crash-logs/ 2>/dev/null || true
          else
            echo "No recent crash logs found for Traval app"
          fi
        fi
        
        # List running apps for debugging
        if [ ! -z "$SIMULATOR_ID" ]; then
          echo "Listing installed apps..."
          xcrun simctl listapps "$SIMULATOR_ID" > "automation/logs/installed-apps.txt" 2>/dev/null || echo "Failed to list apps"
          
          echo "Checking app process status..."
          xcrun simctl spawn "$SIMULATOR_ID" ps aux | grep -i TravalPass > automation/logs/app-processes.txt 2>&1 || echo "No TravalPass processes found"
        fi
        
        # Copy Appium logs if they exist
        if [ -f "automation/simulator.log/appium.log" ]; then
          echo "Appium log found, size: $(wc -l < automation/simulator.log/appium.log) lines"
          tail -200 automation/simulator.log/appium.log > automation/logs/appium-tail.log || true
        else
          echo "‚ö†Ô∏è No Appium log file found at automation/simulator.log/appium.log"
        fi
        
        # List what we captured
        echo "üìã Captured artifacts summary:"
        echo "Screenshots:"
        ls -lah automation/screenshots/ 2>/dev/null || echo "  None"
        echo "Logs:"
        ls -lah automation/logs/ 2>/dev/null || echo "  None"
        echo "Crash logs:"
        ls -lah automation/logs/crash-logs/ 2>/dev/null || echo "  None"
        
        echo "‚úÖ Artifact capture complete"
        
    - name: Dump Appium logs on failure
      if: failure()
      run: |
        echo "üìã Displaying last 200 lines of Appium log for quick debugging:"
        echo "================================================================"
        if [ -f "automation/simulator.log/appium.log" ]; then
          tail -200 automation/simulator.log/appium.log
        else
          echo "‚ö†Ô∏è Appium log file not found"
          echo "Searching for any Appium-related logs..."
          find automation -name "*appium*" -type f 2>/dev/null || echo "No Appium logs found"
        fi
        
    - name: Upload Test Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ios-test-results-${{ github.run_number }}
        path: |
          automation/logs/
          automation/screenshots/
          automation/*.log
          automation/*.png
          automation/*.txt
          
    - name: Cleanup
      if: always()
      run: |
        echo "Cleaning up..."
        
        # Kill Appium server
        if [ ! -z "$APPIUM_PID" ]; then
          echo "Killing Appium server (PID: $APPIUM_PID)"
          kill $APPIUM_PID || true
        fi
        
        # Kill any remaining appium processes
        echo "Cleaning up any remaining Appium processes..."
        pkill -f appium || true
        pkill -f "node.*appium" || true
        
        # Shutdown simulator
        if [ ! -z "$SIMULATOR_ID" ]; then
          echo "Shutting down simulator: $SIMULATOR_ID"
          xcrun simctl shutdown "$SIMULATOR_ID" || true
        fi
        
        # Clean up build artifacts to save space
        rm -rf ios/build || true
        rm -rf ~/Library/Developer/Xcode/DerivedData/* || true